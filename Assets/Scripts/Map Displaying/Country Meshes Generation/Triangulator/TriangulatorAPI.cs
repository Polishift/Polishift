using UnityEngine;
using System.Collections;
using System.IO;
using System.Collections.Generic;
using System;
using MeshesGeneration.Triangulator;

public class TriangleAPI
{
    // Use this for initialization
    public Polygon2D Triangulate(PSLG pslg)
    {
        if (pslg.vertices.Count == 0)
        {
            Debug.LogError("No vertices passed to triangle. hole count: " + pslg.holes.Count + ", vert count: " +
                           pslg.vertices.Count);
            return new Polygon2D(new int[] { }, new Vector2[] { });
        }
        else
        {
            // Write poly file
            WritePolyFile(pslg);

            // Execute Triangle
            ExecuteTriangle();

            // Read outout
            Vector2[] vertices = ReadVerticesFile();
            int[] triangles = ReadTrianglesFile();

            CleanUp();

            return new Polygon2D(triangles, vertices);
        }
    }

    private void WritePolyFile(PSLG pslg)
    {
        try
        {
            string polyFilePath = GetPathToTriangleProgram() + "polygon.poly";
            if (File.Exists(polyFilePath))
            {
                File.Delete(polyFilePath);
            }

            using (StreamWriter sw = File.CreateText(polyFilePath))
            {
                sw.WriteLine("# polygon.poly");
                sw.WriteLine("# generated by Unity Triangle API");
                sw.WriteLine("#");
                // Vertices
                sw.WriteLine(pslg.GetNumberOfSegments() + " 2 0 1");
                sw.WriteLine("# The polyhedrons.");
                int boundaryMarker = 2;
                int i;
                for (i = 0; i < pslg.vertices.Count; i++)
                {
                    if (i != 0 && pslg.boundaryMarkersForPolygons.Contains(i))
                    {
                        boundaryMarker++;
                    }
                    sw.WriteLine(i + 1 + "\t" + pslg.vertices[i].x + "\t" + pslg.vertices[i].y + "\t" + boundaryMarker);
                }
                int offset = i;
                for (i = 0; i < pslg.holes.Count; i++)
                {
                    sw.WriteLine("# Hole #" + (i + 1));
                    int j;
                    for (j = 0; j < pslg.holes[i].vertices.Count; j++)
                    {
                        sw.WriteLine((offset + j + 1) + "\t" + pslg.holes[i].vertices[j].x + "\t" +
                                     pslg.holes[i].vertices[j].y + "\t" + (boundaryMarker + i + 1));
                    }
                    offset += j;
                }

                // Line segments
                sw.WriteLine();
                sw.WriteLine("# Line segments.");
                sw.WriteLine(pslg.GetNumberOfSegments() + " 1");
                sw.WriteLine("# The polyhedrons.");
                boundaryMarker = 2;
                for (i = 0; i < pslg.segments.Count; i++)
                {
                    if (i != 0 && pslg.boundaryMarkersForPolygons.Contains(i))
                    {
                        boundaryMarker++;
                    }
                    sw.WriteLine(i + 1 + "\t" + (pslg.segments[i][0] + 1) + "\t" + (pslg.segments[i][1] + 1) + "\t" +
                                 boundaryMarker);
                }
                offset = i;
                for (i = 0; i < pslg.holes.Count; i++)
                {
                    sw.WriteLine("# Hole #" + (i + 1));
                    int j;
                    for (j = 0; j < pslg.holes[i].segments.Count; j++)
                    {
                        sw.WriteLine((offset + j + 1) + "\t" + (offset + 1 + pslg.holes[i].segments[j][0]) + "\t" +
                                     (offset + 1 + pslg.holes[i].segments[j][1]) + "  " + (boundaryMarker + i + 1));
                    }
                    offset += j;
                }

                // Holes
                sw.WriteLine();
                sw.WriteLine("# Holes.");
                sw.WriteLine(pslg.holes.Count);
                for (i = 0; i < pslg.holes.Count; i++)
                {
                    Vector2 point = pslg.GetPointInHole(pslg.holes[i]);
                    sw.WriteLine((i + 1) + "\t" + point.x + "\t" + point.y + "\t # Hole #" + (i + 1));
                }
                sw.Close();
            }
        }
        catch (Exception e)
        {
            Debug.LogException(e);
        }
    }

    private void ExecuteTriangle()
    {
        try
        {
            System.Diagnostics.Process process = new System.Diagnostics.Process
            {
                StartInfo =
                {
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true,
                    WorkingDirectory = GetPathToTriangleProgram(),
                    FileName = GetPathToTriangleProgram() + "triangle.exe",
                    Arguments = "-pPq0 polygon.poly"
                }
            };
            process.Start();
            process.WaitForExit();
        }
        catch (System.Exception e)
        {
            Debug.LogException(e);
        }
    }

    Vector2[] ReadVerticesFile()
    {
        Vector2[] vertices = null;
        try
        {
            //ISNT TRIANGLE SUPPOSED TO WRITE TO THIS OR SUMTHIN?
            string outputVerticesFile = GetPathToTriangleProgram() + "polygon.1.node";

            StreamReader sr = File.OpenText(outputVerticesFile);

            string line = sr.ReadLine();
            int n = line.IndexOf("  ", StringComparison.Ordinal);
            int nVerts = int.Parse(line.Substring(0, n));
            vertices = new Vector2[nVerts];

            int whileCount = 0;

            while ((line = sr.ReadLine()) != null)
            {
                int index = -1;
                float x = 0f;
                float y = 0f;
                int c = 0;
                if (!line.Contains("#"))
                {
                    string[] stringBits = line.Split(' ');

                    foreach (string s in stringBits)
                    {
                        if (s != "" && s != " ")
                        {
                            if (c == 0)
                                index = int.Parse(s);
                            else if (c == 1)
                                x = float.Parse(s);
                            else if (c == 2)
                                y = float.Parse(s);

                            c++;
                        }
                    }
                }

                if (index != -1)
                {
                    vertices[index - 1] = new Vector2(x, y);
                }


                whileCount++;
                if (whileCount > 1000)
                {
                    break;
                }
            }
            sr.Close();
        }
        catch (Exception e)
        {
            Debug.LogException(e);
        }

        return vertices;
    }

    private int[] ReadTrianglesFile()
    {
        List<int> triList = null;
        try
        {
            string outputTrianglesFile = GetPathToTriangleProgram() + "polygon.1.ele";

            using (StreamReader sr = File.OpenText(outputTrianglesFile))
            {
                string line = sr.ReadLine();
                int n = line.IndexOf("  ");
                int nTriangles = int.Parse(line.Substring(0, n));
                //int[] triangles = new int[nTriangles * 3];
                triList = new List<int>(nTriangles * 3);

                int count = 0;

                while ((line = sr.ReadLine()) != null)
                {
                    int index = -1;
                    int c = 0;
                    int[] tri = new int[3];
                    if (!line.Contains("#"))
                    {
                        string[] stringBits = line.Split(' ');

                        foreach (string s in stringBits)
                        {
                            if (s != "" && s != " ")
                            {
                                if (c == 0)
                                    index = int.Parse(s);
                                else if (c == 1)
                                    tri[0] = int.Parse(s) - 1;
                                else if (c == 2)
                                    tri[1] = int.Parse(s) - 1;
                                else if (c == 3)
                                    tri[2] = int.Parse(s) - 1;

                                c++;
                            }
                        }
                    }

                    if (index != -1)
                    {
                        triList.AddRange(tri);
                    }

                    count++;
                    if (count > 1000)
                    {
                        break;
                    }
                }

                sr.Close();
            }
        }
        catch (Exception e)
        {
            Debug.LogException(e);
        }

        return triList.ToArray();
    }

    private void CleanUp()
    {
        try
        {
            File.Delete(GetPathToTriangleProgram() + "polygon.1.ele");
            File.Delete(GetPathToTriangleProgram() + "polygon.1.node");
            File.Delete(GetPathToTriangleProgram() + "polygon.poly");
        }
        catch (Exception e)
        {
            Debug.LogException(e);
        }
    }


    private string GetPathToTriangleProgram()
    {
        return Application.dataPath + "\\Scripts\\Map Displaying\\Country Meshes Generation\\Triangulator\\";
    }
}